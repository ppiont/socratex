{
  "formatVersion": "1.0.0",
  "tags": {
    "master": [
      {
        "id": "1",
        "title": "Initialize Next.js Project with Core Dependencies",
        "description": "Set up the foundational Next.js application with TypeScript, Tailwind CSS, and essential AI/math libraries",
        "details": "Run 'npx create-next-app@latest socratex --typescript --tailwind --app' and install core dependencies: 'ai', '@ai-sdk/openai', '@ai-sdk/react', 'katex', 'react-katex', 'uploadthing', '@uploadthing/react'. Configure TypeScript, Tailwind, and environment variables for API keys (OPENAI_API_KEY, ANTHROPIC_API_KEY, GEMINI_API_KEY). Set up basic project structure with app/ directory for Next.js App Router.",
        "testStrategy": "Verify project builds successfully with 'npm run build', TypeScript compilation passes, and environment variables load correctly. Test development server starts without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "2",
        "title": "Implement Basic Chat Interface with Streaming",
        "description": "Create the main chat UI using Vercel AI SDK's useChat hook with message display and input handling",
        "details": "Build the main page component at app/page.tsx using useChat hook. Implement message list with student messages right-aligned (blue background) and tutor messages left-aligned (gray background). Add input textarea with submit button. Include auto-scrolling to latest messages and streaming response display. Style with Tailwind following the clean, focused design specified in PRD. Add loading states and basic keyboard shortcuts (Enter to send, Shift+Enter for newlines).",
        "testStrategy": "Test message sending/receiving, verify streaming works, check responsive design on mobile, validate keyboard shortcuts function correctly. Ensure UI matches specifications from PRD.",
        "priority": "high",
        "dependencies": ["1"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Integrate LLM with Socratic Teaching System Prompt",
        "description": "Create API route for chat with LLM integration and implement the Socratic method system prompt",
        "details": "Create app/api/chat/route.ts using streamText from Vercel AI SDK. Implement the comprehensive Socratic system prompt that enforces: never providing direct answers, asking guiding questions, validating reasoning processes, using LaTeX notation, and maintaining encouraging tone. Start with Gemini 2.0 Flash for free development tier, with option to switch to Claude 3.5 Sonnet for production. Test three-tier progressive hint system (guiding questions → partial information → worked examples).",
        "testStrategy": "Test with various math problems to ensure tutor asks questions instead of giving answers. Verify LaTeX notation appears in responses. Test hint escalation by deliberately giving wrong answers. Validate encouraging, patient responses.",
        "priority": "high",
        "dependencies": ["2"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Implement Math Rendering with KaTeX",
        "description": "Add LaTeX math rendering capabilities to display mathematical notation beautifully",
        "details": "Integrate react-katex with 'katex/dist/katex.min.css' import. Create renderMathContent function that parses message content using regex /(\\$\\$[^$]+\\$\\$|\\$[^$]+\\$)/g to detect inline ($...$) and block ($$...$$) LaTeX notation. Wrap detected LaTeX in InlineMath and BlockMath components. Handle edge cases like escaped dollar signs and invalid LaTeX with fallback to raw text. Update chat interface to use math rendering for all messages.",
        "testStrategy": "Test rendering of various mathematical notation: fractions, radicals, exponents, subscripts, Greek letters, matrices, calculus notation. Verify inline and block math display correctly. Test error handling with malformed LaTeX.",
        "priority": "medium",
        "dependencies": ["3"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Set up Image Upload with UploadThing",
        "description": "Implement image upload functionality for students to submit photos of math problems",
        "details": "Configure UploadThing by creating app/api/uploadthing/core.ts with image upload endpoint (4MB max file size, JPG/PNG/PDF formats). Create ImageUpload component using UploadButton from @uploadthing/react. Integrate upload button into chat interface near the text input. Handle upload states (loading, success, error) and display appropriate feedback. Store uploaded image URLs for processing in next step.",
        "testStrategy": "Test uploading various image formats and sizes. Verify 4MB limit enforcement. Check error handling for unsupported formats. Ensure uploaded images return valid CDN URLs.",
        "priority": "medium",
        "dependencies": ["2"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Implement Vision OCR for Math Problem Extraction",
        "description": "Add vision AI capability to extract math problems from uploaded images and convert to LaTeX",
        "details": "Create app/api/extract-math/route.ts that accepts image URLs and sends them to GPT-4o Vision (or Gemini Vision for development). Use prompt: 'Extract all mathematical notation from this image and return it in LaTeX format. Identify the specific problem to be solved.' Parse the response and return structured JSON with problem text and LaTeX array. Implement confirmation workflow - display parsed problem back to student with 'Is this correct?' before starting tutoring. Add fallback to text input if OCR fails.",
        "testStrategy": "Test with various image conditions: clear textbook photos, handwritten problems, poor lighting, angled shots. Verify 85-95% accuracy on printed math, 82-90% on handwritten. Test error handling and fallback mechanisms.",
        "priority": "medium",
        "dependencies": ["5"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Enhance Socratic Dialogue with Progressive Hint System",
        "description": "Implement sophisticated hint escalation and conversation context management",
        "details": "Enhance the system prompt with detailed three-tier hint instructions: Tier 1 (guiding questions like 'What do we know about...?'), Tier 2 (partial information after 2 failed attempts), Tier 3 (worked example of simpler problem after 3 attempts). Add conversation state tracking to maintain hint levels per problem. Implement response validation that checks reasoning process, not just final answers. Add context management that includes full message history in each LLM call for continuity.",
        "testStrategy": "Test hint progression by deliberately struggling with problems. Verify appropriate escalation from questions to hints to examples. Test context retention across 20+ message exchanges. Validate reasoning process checking vs answer checking.",
        "priority": "medium",
        "dependencies": ["4", "6"],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Add Session Management and Persistence",
        "description": "Implement conversation history persistence and session management features",
        "details": "Initially implement localStorage-based conversation persistence for MVP. Add 'New Session' button to clear history and start fresh. Store conversation messages, hint levels, and current problem context. Implement session restoration on page reload. Add proper cleanup for old sessions. Prepare for future Vercel KV integration by structuring data appropriately with session IDs and TTL considerations.",
        "testStrategy": "Test conversation persistence across browser refreshes. Verify 'New Session' properly clears state. Test localStorage limits and cleanup. Ensure hint levels and context restore correctly.",
        "priority": "medium",
        "dependencies": ["7"],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Implement Error Handling and Edge Cases",
        "description": "Add comprehensive error handling, rate limiting, and edge case management",
        "details": "Implement error boundaries for React components. Add error handling for: LLM API failures with retry logic, image upload failures with clear error messages, OCR timeouts with fallback to text input, network issues with graceful degradation. Add rate limiting for API calls if using paid tiers. Handle edge cases: off-topic messages (redirect to math), requests for direct answers (politely refuse), malformed images (prompt for better quality), session timeouts, and context window exceeded scenarios.",
        "testStrategy": "Test all error scenarios: API timeouts, network failures, bad images, rate limits. Verify graceful degradation and helpful error messages. Test edge cases like requesting answers directly.",
        "priority": "medium",
        "dependencies": ["8"],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Polish UI, Deploy to Production, and Comprehensive Testing",
        "description": "Final UI refinements, production deployment, and systematic testing across math domains",
        "details": "Refine UI styling for consistency and mobile responsiveness. Add loading animations for streaming responses, hover states, and smooth transitions. Deploy to Vercel with proper environment variable configuration. Set up custom domain if needed. Conduct systematic testing across math domains: algebra (linear/quadratic equations), calculus (derivatives/integrals), geometry (proofs), and word problems. Test complete user flows from problem input through tutoring to completion. Optimize performance and add final polish.",
        "testStrategy": "Test all math domains with sample problems. Verify complete user flows work correctly. Check mobile responsiveness across devices. Validate production deployment and environment variables. Test performance under typical usage patterns.",
        "priority": "medium",
        "dependencies": ["9"],
        "status": "pending",
        "subtasks": []
      }
    ]
  }
}
